Implementation Documentation
Car Price Prediction System - Implementation Guide
---
Table of Contents
System Architecture
Implementation Steps
Key Code Snippets
Deployment
---
� System Architecture
Car Price Prediction System Workflow
`
CAR PRICE PREDICTION SYSTEM                     
TechStack               
Streamlit        Data Sources           Machine Learning        
Pandas                                                          
Scikit-learn    • car_dataset     • Data Preprocessing     
Plotly          • launch_years         • Feature Engineering    
Joblib          • encoders.pkl         • Model Training         
NumPy                • Gradient Boosting      
Streamlit App              Model Inference       
Home          • Price Prediction     
Filtering              • Input Validation     
Analysis               • Feature Encoding     
Prediction             • Result Formatting    
Comparison               
User Interface               Data Storage          
• Interactive Forms          • Model Files (.pkl)    
• Real-time Charts           • Dataset (CSV)         
• Glassmorphism UI           • Launch Year Data      
• Responsive Design          • Label Encoders        
`
Data Flow Pipeline
`
Raw Data → Data Cleaning → Feature Engineering → Model Training → Web App → Predictions
↓             ↓                ↓                  ↓            ↓          ↓
• 4000+ cars   • Remove        • Car age          • Gradient    • Streamlit • Price estimation
• CSV format   • outliers      • Brand encoding   • Boosting    • Multi-page• Confidence interval  
• Mixed types  • Fill missing  • Derived metrics  • 87% R²      • Interactive• Market insights
`
---
Implementation Steps
Step 1: Environment Setup
`bash
python -m venv myenv
source myenv/bin/activate
pip install -r requirements.txt
`
Step 2: Data Processing Pipeline
`python
def data_cleaning_pipeline(df):
# Remove duplicates and outliers
df = df.drop_duplicates()
Q1, Q3 = df['selling_price'].quantile([0.25, 0.75])
IQR = Q3 - Q1
df = df[(df['selling_price'] >= Q1-1.5IQR) & (df['selling_price'] <= Q3+1.5IQR)]
# Handle missing values
df['km_driven'].fillna(df['km_driven'].median(), inplace=True)
df['fuel_type'].fillna(df['fuel_type'].mode()[0], inplace=True)
return df
`
Step 3: Feature Engineering
`python
def feature_engineering(df, current_year=2024):
# Most important feature: car age
df['car_age'] = current_year - df['year']
# Performance metrics
df['power_to_engine_ratio'] = df['max_power'] / df['engine']
df['efficiency_score'] = df['mileage'] / df['engine'] * 1000
return df
`
Step 4: Model Training
`python
from sklearn.ensemble import GradientBoostingRegressor
Train the main model
model = GradientBoostingRegressor(
n_estimators=150,
learning_rate=0.1,
max_depth=6,
random_state=42
)
model.fit(X_train, y_train)
joblib.dump(model, 'GradientBoost_model.pkl')
`
Step 5: Streamlit Application
`python
Main.py - Application entry point
import streamlit as st
st.set_page_config(page_title="Car Price Predictor", layout="wide")
Navigation
menu = st.sidebar.radio("Dashboard", [
"🏠 Home", " Filtering", " Analysis", 
" Prediction", " Comparison"
])
Route to pages
if menu == " Prediction":
Prediction.app()
`
---
Key Code Snippets
Core Prediction Engine
`python
class CarPricePredictionEngine:
def __init__(self):
self.model = joblib.load("GradientBoost_model.pkl")
self.encoders = joblib.load("label_encoders.pkl")
def predict_price(self, features):
# Validate inputs
errors = self.validate_inputs(features)
if errors:
return None, errors
# Encode categorical features
encoded_features = self.encode_features(features)
# Create feature vector
feature_vector = np.array([
encoded_features['brand'], encoded_features['model'],
encoded_features['car_age'], encoded_features['km_driven'],
encoded_features['engine'], encoded_features['max_power'],
encoded_features['mileage'], encoded_features['fuel_type'],
encoded_features['transmission'], encoded_features['seats']
]).reshape(1, -1)
# Make prediction
prediction = self.model.predict(feature_vector)[0]
final_price = max(0.5, prediction)
return {'predicted_price': final_price}, None
`
Interactive UI Components
`python
Prediction form
def create_prediction_form():
col1, col2 = st.columns(2)
with col1:
brand = st.selectbox("🚘 Brand", brands)
model = st.selectbox(" Model", models)
year = st.selectbox("📅 Year", range(2024, 1979, -1))
km_driven = st.number_input(" KM Driven", 0, 500000, 25000)
with col2:
fuel_type = st.selectbox(" Fuel Type", fuel_types)
transmission = st.selectbox(" Transmission", transmissions)
engine = st.number_input(" Engine (CC)", 500, 5000, 1200)
max_power = st.number_input(" Power (bhp)", 30.0, 1000.0, 85.0)
return {
'brand': brand, 'model': model, 'year': year,
'km_driven': km_driven, 'fuel_type': fuel_type,
'transmission': transmission, 'engine': engine,
'max_power': max_power
}
`
Data Visualization
`python
import plotly.express as px
def create_price_analysis():
# Brand distribution
fig = px.pie(df['brand'].value_counts(), 
title="Brand Distribution")
st.plotly_chart(fig)
# Age vs Price correlation
fig = px.scatter(df, x='car_age', y='selling_price',
color='fuel_type', trendline="ols")
st.plotly_chart(fig)
`
Model Performance Monitoring
`python
def evaluate_model_performance(model, X_test, y_test):
predictions = model.predict(X_test)
metrics = {
'r2_score': r2_score(y_test, predictions),
'mae': mean_absolute_error(y_test, predictions),
'rmse': np.sqrt(mean_squared_error(y_test, predictions))
}
return metrics
Results: R² = 0.87, MAE = 1.89 lakhs, RMSE = 2.67 lakhs
`
---
Deployment
Local Development
`bash
Run the application
streamlit run Main.py
`
Production Deployment
`dockerfile
Dockerfile
FROM python:3.9-slim
WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt
COPY . .
EXPOSE 8501
CMD ["streamlit", "run", "Main.py"]
`
Performance Metrics
• Model Accuracy: 87% R² score
• Response Time: <2 seconds
• Data Processing: 4,000+ car records
• Concurrent Users: 50+ supported
---
Implementation Guide - Car Price Prediction System
Author: Argus-66 | Date: September 30, 2025